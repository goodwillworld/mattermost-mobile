workflows:
  ios-mattermost-release:
    name: Mattermost iOS (App Groups + Push, no Expo)
    instance_type: mac_mini_m2
    max_build_duration: 60

    environment:
      groups:
        - ios_match
      vars:
        APP_NAME: "Mattermost"
        MAIN_BUNDLE_ID: "com.jboth.mine"
        SHARE_BUNDLE_ID: "com.jboth.mine.MattermostShare"
        NOTI_BUNDLE_ID: "com.jboth.mine.NotificationService"
        APP_GROUP_ID: "group.com.jboth.mine"
        CI: "true"
      ios_signing:
        # 如果你要走 Ad Hoc，请把 distribution_type 改成 ad_hoc
        distribution_type: app_store     # app_store | ad_hoc | development | enterprise
        bundle_identifier: com.jboth.mine

    scripts:
      - name: Print Xcode / Ruby / CocoaPods versions
        script: |
          xcodebuild -version
          ruby -v
          pod --version

      - name: Use Node 20 LTS (via nvm，无 nvm 时自动回退)
        script: |
          set -e
          export NVM_DIR="$HOME/.nvm"
          if [ -s "$NVM_DIR/nvm.sh" ]; then
            . "$NVM_DIR/nvm.sh"
            nvm install 20
            nvm use 20
          else
            echo "nvm not found, fallback to Homebrew node@20"
            brew update || true
            brew install node@20 || true
            echo 'export PATH="/opt/homebrew/opt/node@20/bin:$PATH"' >> $BASH_ENV
            source $BASH_ENV
          fi
          node -v
          npm -v || true
          yarn -v || true

      - name: Install JS deps (project root)
        script: |
          # 若使用 npm：改为 npm ci
          yarn install --frozen-lockfile || npm ci

      - name: Patch Podfile resolver (point to project root)
        script: |
          set -e
          PODFILE="ios/Podfile"
          if [ -f "$PODFILE" ]; then
            ruby - <<'RUBY'
            path = "ios/Podfile"
            s = File.read(path)
            if s.include?("require Pod::Executable.execute_command('node', ['-p'")
              s.gsub!(
                /require Pod::Executable.execute_command\(\s*'node'.*?\)\s*\]/m,
                "react_native_pods = Pod::Executable.execute_command(\n  'node',\n  [\n    '-p',\n    <<~'NODE',\n      require.resolve(\n        'react-native/scripts/react_native_pods.rb',\n        { paths: [process.argv[1]] },\n      )\n    NODE,\n    Pod::Config.instance.project_root.to_s\n  ]\n)\nrequire react_native_pods"
              )
              File.write(path, s)
              puts "Patched Podfile resolver to use project_root"
            else
              puts "Podfile resolver already modernized or not matching; skip."
            end
            RUBY
          else
            echo "Podfile not found at ios/Podfile"
          fi

      - name: Create setup_signing.sh (strict) and run
        script: |
          set -e
          mkdir -p scripts
          cat > scripts/setup_signing.sh <<'EOF'
          #!/usr/bin/env bash
          set -euo pipefail

          MAIN_BUNDLE_ID="${MAIN_BUNDLE_ID:?}"
          SHARE_BUNDLE_ID="${SHARE_BUNDLE_ID:?}"
          NOTI_BUNDLE_ID="${NOTI_BUNDLE_ID:?}"
          APP_GROUP_ID="${APP_GROUP_ID:?}"

          ROOT="$(pwd)"
          IOS_DIR="${ROOT}/ios"

          APP_ENT="${IOS_DIR}/Mattermost/Mattermost.entitlements"
          SHARE_ENT="${IOS_DIR}/MattermostShare/MattermostShare.entitlements"
          NOTI_ENT="${IOS_DIR}/NotificationService/NotificationService.entitlements"

          ensure_dirs () {
            mkdir -p "$(dirname "$APP_ENT")" "$(dirname "$SHARE_ENT")" "$(dirname "$NOTI_ENT")"
          }

          create_min_plist () {
            local file="$1"
            cat > "$file" <<PL
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict/>
          </plist>
          PL
          }

          normalize_plist () {
            local file="$1"
            if [ ! -f "$file" ]; then
              create_min_plist "$file"
              return 0
            fi
            if ! /usr/bin/plutil -lint "$file" >/dev/null 2>&1; then
              echo "WARN: $file invalid, recreating"
              create_min_plist "$file"
              return 0
            fi
            local type
            type="$(/usr/bin/plutil -p "$file" 2>/dev/null | head -n1 || true)"
            if [[ "${type:-}" != \{* ]]; then
              echo "WARN: $file top-level not dict, recreating"
              create_min_plist "$file"
            fi
          }

          ensure_app_group () {
            local file="$1"
            normalize_plist "$file"
            if /usr/libexec/PlistBuddy -c "Print :com.apple.security.application-groups" "$file" >/dev/null 2>&1; then
              if ! /usr/libexec/PlistBuddy -c "Print :com.apple.security.application-groups" "$file" 2>&1 | head -n1 | grep -q "Array {"; then
                /usr/libexec/PlistBuddy -c "Delete :com.apple.security.application-groups" "$file" || true
              fi
            fi
            /usr/libexec/PlistBuddy -c "Add :com.apple.security.application-groups array" "$file" 2>/dev/null || true
            local COUNT="$(/usr/libexec/PlistBuddy -c "Print :com.apple.security.application-groups" "$file" 2>/dev/null | grep -E '^\s*[0-9]+\s*=' | wc -l | tr -d ' ')"
            if [[ "${COUNT:-0}" -gt 0 ]]; then
              for (( i=COUNT-1; i>=0; i-- )); do
                /usr/libexec/PlistBuddy -c "Delete :com.apple.security.application-groups:$i" "$file" || true
              done
            fi
            /usr/libexec/PlistBuddy -c "Add :com.apple.security.application-groups:0 string ${APP_GROUP_ID}" "$file"
            echo "OK: Set App Group in $(basename "$file")"
          }

          patch_pbxproj () {
            local pbx="${IOS_DIR}/Mattermost.xcodeproj/project.pbxproj"
            echo "==> Patching ${pbx}"
            python3 - "$pbx" "$MAIN_BUNDLE_ID" "$SHARE_BUNDLE_ID" "$NOTI_BUNDLE_ID" <<'PY'
          import sys, re, io
          pbx, main_bid, share_bid, noti_bid = sys.argv[1:5]
          s = io.open(pbx, 'r', encoding='utf-8').read()

          def subn(pat, rep, s):
            new, n = re.subn(pat, rep, s, flags=re.M|re.S)
            return new, n

          mapping_ents = {
            "Mattermost": "Mattermost/Mattermost.entitlements",
            "MattermostShare": "MattermostShare/MattermostShare.entitlements",
            "NotificationService": "NotificationService/NotificationService.entitlements",
          }
          mapping_bids = {
            "Mattermost": main_bid,
            "MattermostShare": share_bid,
            "NotificationService": noti_bid,
          }

          for name, ent in mapping_ents.items():
            pat = r'(\/\* %s \*\/[\\s\\S]*?CODE_SIGN_ENTITLEMENTS\\s*=)\\s*[^;]+;' % re.escape(name)
            s, n1 = subn(pat, r'\\1 %s;' % ent, s)
            pat2 = r'(CODE_SIGN_ENTITLEMENTS\\s*=)\\s*[^;]+;([\\s\\S]{0,400}PRODUCT_NAME\\s*=\\s*"?%s"?;)' % re.escape(name)
            s, n2 = subn(pat2, r'\\1 %s;\\2' % ent, s)
            pat3 = r'(\/\* %s \*\/[\\s\\S]*?PRODUCT_BUNDLE_IDENTIFIER\\s*=)\\s*[^;]+;' % re.escape(name)
            s, n3 = subn(pat3, r'\\1 %s;' % mapping_bids[name], s)
            pat4 = r'(PRODUCT_BUNDLE_IDENTIFIER\\s*=)\\s*[^;]+;([\\s\\S]{0,400}PRODUCT_NAME\\s*=\\s*"?%s"?;)' % re.escape(name)
            s, n4 = subn(pat4, r'\\1 %s;\\2' % mapping_bids[name], s)
            print(f"{name}: entitlements patched {n1+n2} time(s), bundle id patched {n3+n4} time(s)")

          io.open(pbx, 'w', encoding='utf-8').write(s)
          print("PBXProject patch complete")
          PY
          }

          echo "==> Ensuring directories"
          ensure_dirs

          echo "==> Ensuring entitlements include App Group ${APP_GROUP_ID}"
          ensure_app_group "$APP_ENT"
          ensure_app_group "$SHARE_ENT"
          ensure_app_group "$NOTI_ENT"

          patch_pbxproj

          echo "Summary:"
          echo "  App bundle id:        ${MAIN_BUNDLE_ID}"
          echo "  Share bundle id:      ${SHARE_BUNDLE_ID}"
          echo "  Notification bundle:  ${NOTI_BUNDLE_ID}"
          echo "  App Group:            ${APP_GROUP_ID}"
          EOF
          chmod +x scripts/setup_signing.sh
          bash scripts/setup_signing.sh

      - name: Install pods
        script: |
          cd ios
          pod repo update || true
          pod install --repo-update

      - name: Apply provisioning profiles to Xcode project
        script: |
          # 将已上传/抓取到的 profiles 引用到 Xcode 工程
          xcode-project use-profiles

      - name: Generate export options (App Store)
        script: |
          # 如果你要 Ad Hoc 出包用于企业分发/真机安装，把 method 改成 ad-hoc，并将 ios_signing.distribution_type 改为 ad_hoc
          cat > export_options.plist <<'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key><string>app-store</string>
            <key>signingStyle</key><string>manual</string>
            <key>destination</key><string>export</string>
            <key>compileBitcode</key><false/>
          </dict>
          </plist>
          EOF

      - name: Build archive
        script: |
          cd ios
          xcodebuild -workspace Mattermost.xcworkspace \
            -scheme Mattermost \
            -configuration Release \
            -archivePath build/ios/xcarchive/Mattermost.xcarchive \
            CODE_SIGN_STYLE=Manual \
            COMPILER_INDEX_STORE_ENABLE=NO \
            archive | xcpretty && exit ${PIPESTATUS[0]}

      - name: Export IPA
        script: |
          cd ios
          xcodebuild -exportArchive \
            -archivePath build/ios/xcarchive/Mattermost.xcarchive \
            -exportPath ipa \
            -exportOptionsPlist ../export_options.plist | xcpretty && exit ${PIPESTATUS[0]}

    artifacts:
      - ios/ipa/*.ipa
      - ios/build/**/*.xcarchive

    publishing:
      app_store_connect:
        api_key: "$APP_STORE_CONNECT_PRIVATE_KEY"
        key_id: "$APP_STORE_CONNECT_KEY_ID"
        issuer_id: "$APP_STORE_CONNECT_ISSUER_ID"
        submit_to_testflight: true
      email:
        recipients:
          - bill.fan4java@gmail.com
