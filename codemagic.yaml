workflows:
  # ========= ANDROID：白标 + 生成 APK（自行分发），不发布到商店 =========
  mm-whitelabel-android-sideload:
    name: Mattermost WhiteLabel ANDROID (sideload)
    max_build_duration: 120
    instance_type: linux_x2
    environment:
      android_signing:
        - jboth_android_keystore_ref
      groups:
        - mm_common
        - jboth_client
      vars:
        BUILD_FOR_RELEASE: "true"
        ANDROID_BUILD_TASK: "assemble" # assemble=APK；bundle=AAB
        REPLACE_ASSETS: "true"
        GYM_EXPORT_METHOD: "app-store" 
    cache:
      cache_paths:
        - $HOME/.gradle/caches
        - node_modules
    scripts:
      - name: Node 环境与依赖
        script: |
          set -e
          export NVM_DIR="$HOME/.nvm"
          if [ -f ".nvmrc" ] && [ -s "$NVM_DIR/nvm.sh" ]; then
            . "$NVM_DIR/nvm.sh"
            nvm install --silent
            nvm use --silent
          else
            echo "⚠️ 未检测到 nvm，使用系统 Node"
            which node || true
            node -v || true
            npm -v || true
          fi
          npm ci

      - name: 注入签名（Gradle）
        script: |
          mkdir -p $HOME/.gradle
          cat >> $HOME/.gradle/gradle.properties <<EOF
          MATTERMOST_RELEASE_STORE_FILE=$CM_KEYSTORE_PATH
          MATTERMOST_RELEASE_KEY_ALIAS=$CM_KEY_ALIAS
          MATTERMOST_RELEASE_PASSWORD=$CM_KEY_PASSWORD
          EOF

      - name: 写入/兜底默认服务器配置（如仓库中已存在将不会覆盖）
        script: |
          set -e
          mkdir -p assets/override
          CFG=assets/override/config.json
          if [ ! -f "$CFG" ]; then
            cat > "$CFG" <<'JSON'
          {
            "DefaultServerUrl": "https://hello.jboth.com",
            "AutoSelectServerUrl": true
          }
          JSON
            echo "Created $CFG with default server URL."
          else
            echo "Found existing $CFG, keep your repo version."
          fi

      - name: 白标变量确认
        script: |
          echo "APP_NAME=$APP_NAME"
          echo "MAIN_APP_IDENTIFIER=$MAIN_APP_IDENTIFIER"
          echo "APP_SCHEME=$APP_SCHEME"

      - name: 构建（优先使用仓库自带 lane）
        script: |
          set -e
          npm run build:android || echo "lane 构建失败，尝试 Gradle 兜底…"

      - name: 兜底：直接 Gradle 生成 APK（如 lane 只产出 AAB）
        script: |
          set -e
          cd android
          ./gradlew assembleRelease \
            -Pandroid.injected.signing.store.file="$CM_KEYSTORE_PATH" \
            -Pandroid.injected.signing.store.password="$CM_KEY_PASSWORD" \
            -Pandroid.injected.signing.key.alias="$CM_KEY_ALIAS" \
            -Pandroid.injected.signing.key.password="$CM_KEY_PASSWORD" || true
          cd -

      - name: 收集制品（APK/AAB）
        script: |
          mkdir -p $CM_ARTIFACTS
          find . -type f -name "*release*.apk" -maxdepth 6 -print -exec cp -f {} $CM_ARTIFACTS \; || true
          find . -type f -name "*.aab" -maxdepth 6 -print -exec cp -f {} $CM_ARTIFACTS \; || true
    # 不写 publishing：仅在 Artifacts 输出安装包

  # ========= iOS：白标 + TestFlight/App Store 分发 =========
  mm-whitelabel-ios:
    name: Mattermost WhiteLabel iOS (TestFlight/App Store)
    max_build_duration: 120
    instance_type: mac_mini_m2

    environment:
      groups:
        - mm_common
        - jboth_client
        - ios_match
      vars:
        BUILD_FOR_RELEASE: "true"
        REPLACE_ASSETS: "true"
        GYM_EXPORT_METHOD: "app-store"
        # 必备（Secret）：
        # FASTLANE_TEAM_ID、MATCH_USERNAME、MATCH_PASSWORD、
        # MATCH_APP_IDENTIFIER（逗号分隔：com.jboth.mine,com.jboth.mine.MattermostShare,com.jboth.mine.NotificationService）、
        # MATCH_TYPE=appstore、GITHUB_PAT、
        # ASC_KEY_ID、ASC_ISSUER_ID、ASC_PRIVATE_KEY

    cache:
      cache_paths:
        - $HOME/Library/Caches/CocoaPods
        - ios/Pods
        - node_modules

    scripts:
      - name: 环境与依赖（Node + watchman + CocoaPods 1.16.1）
        script: |
          set -e
          echo "▶ Using system Node"
          which node || true
          node -v || true
          npm -v || true

          echo "▶ Install watchman（Solidarity 需要）"
          if command -v brew >/dev/null 2>&1; then
            eval "$(/opt/homebrew/bin/brew shellenv)" || true
            brew list watchman >/dev/null 2>&1 || brew install watchman
            watchman --version || true
          else
            echo "❌ Homebrew 未找到，无法安装 watchman"; exit 1
          fi

          echo "▶ Pin CocoaPods 1.16.1（用户 gem 目录）"
          export GEM_HOME="$HOME/.gem"
          export GEM_PATH="$GEM_HOME"
          export PATH="$GEM_HOME/bin:$PATH"
          gem list -i cocoapods -v 1.16.1 || gem install cocoapods -v 1.16.1 --no-document
          unset RUBYOPT BUNDLE_GEMFILE BUNDLE_BIN_PATH BUNDLE_PATH BUNDLER_ORIG_PATH BUNDLER_ORIG_MANPATH || true
          echo "pod path: $(command -v pod || echo 'not found')"
          env -i PATH="$PATH" GEM_HOME="$GEM_HOME" GEM_PATH="$GEM_PATH" HOME="$HOME" LANG="${LANG:-en_US.UTF-8}" pod _1.16.1_ --version

          echo "▶ npm ci"
          npm ci

      - name: Ruby/Fastlane + CocoaPods（用固定的 1.16.1 执行）
        script: |
          set -e
          # 强制 rbenv 使用已装 Ruby（覆盖 .ruby-version 的 3.2.0），并临时屏蔽 .ruby-version
          if command -v rbenv >/dev/null 2>&1; then
            RB_INST="$(rbenv versions --bare | grep -E '^[0-9]+\.[0-9]+' | tail -1 || true)"
            export RBENV_VERSION="${RB_INST:-system}"
            echo "Using rbenv Ruby: ${RBENV_VERSION}"
          fi
          ruby -v || true
          if [ -f .ruby-version ]; then
            mv .ruby-version .ruby-version.bak
            trap 'mv .ruby-version.bak .ruby-version 2>/dev/null || true' EXIT
          fi
          cd ios
          RBENV_VERSION="${RBENV_VERSION}" \
          GEM_HOME="$HOME/.gem" GEM_PATH="$HOME/.gem" HOME="$HOME" LANG="${LANG:-en_US.UTF-8}" \
          pod _1.16.1_ install --repo-update
          cd ..

      - name: 🔧 Patch Pods project (purge any .modulemap from ALL build phases)
        script: |
          set -e
          cd ios

          # 写入临时 Ruby（避免 here-doc 缩进问题）
          cat > /tmp/patch_pods_modulemap.rb <<'RB'
            require 'xcodeproj'

            proj_path = 'Pods/Pods.xcodeproj'
            abort("Pods project not found: #{proj_path}") unless File.exist?(proj_path)
            proj = Xcodeproj::Project.open(proj_path)

            TARGET_NAME = 'TurboLogIOSNative'
            REMOVED = []

            proj.targets.each do |t|
              next unless t.name == TARGET_NAME

              # 遍历所有 Build Phase（Sources/Headers/Resources/CopyFiles 等）
              t.build_phases.each do |phase|
                files = (phase.respond_to?(:files) ? phase.files : []) || []
                files.dup.each do |bf|
                  fr = bf.file_ref
                  next unless fr && fr.path && fr.path.end_with?('.modulemap')
                  bf.remove_from_project
                  REMOVED << "#{t.name} :: #{phase.display_name || phase.class} :: #{fr.path}"
                end
              end

              # 保险：把 MODULEMAP_FILE 指到源码路径，同时不强制拷贝
              candidate = '$(SRCROOT)/TurboLogIOSNative/Sources/TurboLogSwift/module.modulemap'
              t.build_configurations.each do |cfg|
                cfg.build_settings['MODULEMAP_FILE'] = candidate
                # 如果三方库误把 modulemap 当资源复制，关闭下：
                cfg.build_settings['COPY_PHASE_STRIP'] = 'NO'
              end
            end

            proj.save
            puts "✅ Removed #{REMOVED.size} .modulemap entries from build phases"
            REMOVED.each { |r| puts " - #{r}" }
          RB

          ruby /tmp/patch_pods_modulemap.rb
          cd ..

      - name: 🔄 Force export method to App Store (hard override)
        script: |
          set -e

          echo "▶ Set env for gym"
          export GYM_EXPORT_METHOD=app-store
          echo "GYM_EXPORT_METHOD=$GYM_EXPORT_METHOD"

          # 1) Fastfile 中常见字符串写法：export_method: 'ad-hoc' / "ad-hoc"
          if [ -f fastlane/Fastfile ]; then
            echo "▶ Patching fastlane/Fastfile"
            cp fastlane/Fastfile fastlane/Fastfile.bak

            # a) 字符串写法（单/双引号）
            sed -i.bak -E "s/export_method:[[:space:]]*['\"]ad-?hoc['\"]/export_method: 'app-store'/g" fastlane/Fastfile || true
            # b) 符号写法 :ad_hoc  -> :app_store
            sed -i.bak -E "s/:ad_?hoc/:app_store/g" fastlane/Fastfile || true
            # c) 另一种字符串写法（无空格）
            sed -i.bak -E "s/export_method:['\"]ad-?hoc['\"]/export_method: 'app-store'/g" fastlane/Fastfile || true

            echo "▶ After patch, show gym/export_method lines for review"
            awk 'NR>=p && NR<=p+20{print NR":",$0} /gym\(/ {p=NR} /export_method/ {print NR":",$0}' fastlane/Fastfile || true
            echo "▶ Grep export_method:"
            grep -n "export_method" fastlane/Fastfile || true
          fi

          # 2) 如仓库使用 ExportOptions.plist（有时在 fastlane/ 或 ios/fastlane/）
          echo "▶ Looking for ExportOptions.plist"
          FOUND_PLISTS=$( (ls -1 fastlane/ExportOptions.plist 2>/dev/null || true; \
                          ls -1 ios/fastlane/ExportOptions.plist 2>/dev/null || true; \
                          find . -maxdepth 3 -name ExportOptions.plist 2>/dev/null || true) | sort -u )
          if [ -n "$FOUND_PLISTS" ]; then
            echo "$FOUND_PLISTS" | while read f; do
              [ -f "$f" ] || continue
              echo "  - Patch $f -> method=app-store"
              /usr/libexec/PlistBuddy -c "Set :method app-store" "$f" 2>/dev/null || \
              /usr/libexec/PlistBuddy -c "Add :method string app-store" "$f" 2>/dev/null || true

              # 可选：确保 provisioningProfiles 节不强行指定 Ad Hoc 的映射
              # 如果这里有旧的 adhoc 映射，你可以先删再让 fastlane/match 注入
              /usr/libexec/PlistBuddy -c "Delete :provisioningProfiles" "$f" 2>/dev/null || true

              echo "  - Dump $f"
              /usr/libexec/PlistBuddy -c "Print" "$f" || true
            done
          else
            echo "  (no ExportOptions.plist found, OK)"
          fi

          # 3) 防呆：如仍残留 ad-hoc 痕迹则直接失败，避免继续浪费时间
          if [ -f fastlane/Fastfile ] && grep -qE "export_method:[[:space:]]*['\"]ad-?hoc['\"]|:ad_?hoc" fastlane/Fastfile; then
            echo "❌ Fastfile 仍包含 ad-hoc，请检查替换规则或把相关片段贴出来我来精确改"
            exit 1
          fi

          echo "✅ export_method 强制为 app-store"


      - name: 配置证书库（HTTPS + Token）并自检
        script: "set -e; if [ -z \"${GITHUB_PAT:-}\" ]; then echo '❌ 缺少 GITHUB_PAT'; exit 1; fi; export MATCH_GIT_URL=\"https://${GITHUB_PAT}@github.com/goodwillworld/ios-certs.git\"; echo 'MATCH_GIT_URL set (token masked)'; git -c credential.helper= ls-remote \"$MATCH_GIT_URL\" >/dev/null; echo '✅ match 证书库可访问（HTTPS+Token）'; export SIGH_GIT_URL=\"$MATCH_GIT_URL\""

      - name: 自检关键变量（不会泄露）
        script: |
          set -e
          check_var() { if [ -z "${!1}" ]; then echo "❌ MISSING $1"; exit 1; else echo "✅ $1 OK"; fi; }
          check_var FASTLANE_TEAM_ID
          check_var MATCH_USERNAME
          check_var MATCH_PASSWORD
          check_var MATCH_GIT_URL
          check_var MATCH_APP_IDENTIFIER
          check_var MATCH_TYPE
          check_var ASC_KEY_ID
          check_var ASC_ISSUER_ID
          if [ -z "$ASC_PRIVATE_KEY" ]; then echo "❌ MISSING ASC_PRIVATE_KEY"; exit 1; else echo "✅ ASC_PRIVATE_KEY OK (hidden)"; fi

      - name: 首次初始化签名（仅当证书库为空时执行）
        script: |
          set -e
          : "${MATCH_GIT_URL:?缺少 MATCH_GIT_URL}"
          : "${FASTLANE_TEAM_ID:?缺少 FASTLANE_TEAM_ID}"
          : "${MATCH_APP_IDENTIFIER:?缺少 MATCH_APP_IDENTIFIER（逗号分隔多个ID）}"
          : "${ASC_KEY_ID:?缺少 ASC_KEY_ID}"
          : "${ASC_ISSUER_ID:?缺少 ASC_ISSUER_ID}"
          : "${ASC_PRIVATE_KEY:?缺少 ASC_PRIVATE_KEY}"

          # 仓库是否为空（无分支）
          if [ "$(git -c credential.helper= ls-remote --heads "$MATCH_GIT_URL" | wc -l | tr -d ' ')" -gt 0 ]; then
            echo "ℹ️ 证书库非空，跳过初始化"
            exit 0
          fi
          echo "🆕 空仓库：执行首轮初始化（创建证书/描述文件并 push）"

          # 安装 fastlane（按需）
          if [ -f Gemfile ] && grep -qi 'fastlane' Gemfile; then
            gem install bundler --no-document
            bundle install
            FL="bundle exec fastlane"
          else
            gem install fastlane -v 2.228.0 --no-document || gem install fastlane --no-document
            FL="fastlane"
          fi
          $FL --version

          # 生成 ASC API Key JSON（安全转义）
          python3 - <<'PY'
          import os, json
          data={
            "key_id": os.environ["ASC_KEY_ID"].strip(),
            "issuer_id": os.environ["ASC_ISSUER_ID"].strip(),
            "key": os.environ["ASC_PRIVATE_KEY"].replace("\r\n","\n").replace("\r","\n"),
            "in_house": False
          }
          open("asc_api_key.json","w").write(json.dumps(data))
          PY
          python3 -m json.tool asc_api_key.json >/dev/null && echo "✅ asc_api_key.json OK"

          # 临时 keychain，避免交互
          KEYCHAIN_PWD="${KEYCHAIN_PWD:-$(uuidgen)}"
          $FL run create_keychain name:"cm_tmp" password:"$KEYCHAIN_PWD" default_keychain:true unlock:true timeout:3600

          # Git 用户信息（用于首次提交）
          git config --global user.email "codemagic@local"
          git config --global user.name  "Codemagic CI"

          # 首轮创建（readonly:false）— 现在 Apple Dev Portal 里已有 3 个 App ID
          $FL run match \
            type:"appstore" \
            readonly:"false" \
            git_url:"$MATCH_GIT_URL" \
            app_identifier:"$MATCH_APP_IDENTIFIER" \
            team_id:"$FASTLANE_TEAM_ID" \
            api_key_path:"asc_api_key.json" \
            keychain_name:"cm_tmp" \
            keychain_password:"$KEYCHAIN_PWD" \
            verbose:true

          echo "✅ 初始化完成：后续 match 可只读"

      - name: 构建 iOS（使用仓库 lane）
        script: |
          set -e
          export GYM_EXPORT_METHOD=app-store 
          npm run build:ios

      - name: 收集制品
        script: |
          mkdir -p $CM_ARTIFACTS
          find . -type f -name "*.ipa" -maxdepth 6 -print -exec cp -f {} $CM_ARTIFACTS \; || true

    publishing:
      app_store_connect:
        api_key: |
          -----BEGIN PRIVATE KEY-----
          MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgTHFCUEmtmzuEaG/T
          zD5C5EBtEBsuWf54ZxCbWmpD/lugCgYIKoZIzj0DAQehRANCAAS6nYsA0zoFzGbY
          t9rYpOKdcq0hG8zmImfhjOct0m609Z/J4fOcoxeLd3LJr4DAo6Kk+PBeCFBvrxIl
          j5J7JvfX
          -----END PRIVATE KEY-----
        key_id: "UZ33M397NY"
        issuer_id: "26e601c9-c2f0-497a-a9e1-39a426cecf9a"
        submit_to_testflight: true
