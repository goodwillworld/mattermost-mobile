workflows:
  mm-whitelabel-android-sideload:
    name: Mattermost WhiteLabel ANDROID (sideload)
    max_build_duration: 120
    instance_type: linux_x2
    environment:
      android_signing:
        - jboth_android_keystore_ref
      groups:
        - mm_common
        - jboth_client
      vars:
        BUILD_FOR_RELEASE: 'true'
        ANDROID_BUILD_TASK: assemble
        REPLACE_ASSETS: 'true'
    cache:
      cache_paths:
        - $HOME/.gradle/caches
        - node_modules
    scripts:
      - name: Node 环境与依赖
        script: |
          set -e
          export NVM_DIR="$HOME/.nvm"
          if [ -f ".nvmrc" ] && [ -s "$NVM_DIR/nvm.sh" ]; then
            . "$NVM_DIR/nvm.sh"
            nvm install --silent
            nvm use --silent
          else
            echo "⚠️ 未检测到 nvm，使用系统 Node"
            which node || true
            node -v || true
            npm -v || true
          fi
          npm ci
      - name: 注入签名（Gradle）
        script: |
          mkdir -p $HOME/.gradle
          cat >> $HOME/.gradle/gradle.properties <<EOF
          MATTERMOST_RELEASE_STORE_FILE=$CM_KEYSTORE_PATH
          MATTERMOST_RELEASE_KEY_ALIAS=$CM_KEY_ALIAS
          MATTERMOST_RELEASE_PASSWORD=$CM_KEY_PASSWORD
          EOF
      - name: 写入/兜底默认服务器配置（如仓库中已存在将不会覆盖）
        script: |
          set -e
          mkdir -p assets/override
          CFG=assets/override/config.json
          if [ ! -f "$CFG" ]; then
            cat > "$CFG" <<'JSON'
          {
            "DefaultServerUrl": "https://hello.jboth.com",
            "AutoSelectServerUrl": true
          }
          JSON
            echo "Created $CFG with default server URL."
          else
            echo "Found existing $CFG, keep your repo version."
          fi
      - name: 白标变量确认
        script: |
          echo "APP_NAME=$APP_NAME"
          echo "MAIN_APP_IDENTIFIER=$MAIN_APP_IDENTIFIER"
          echo "APP_SCHEME=$APP_SCHEME"
      - name: 构建（优先使用仓库自带 lane）
        script: |
          set -e
          npm run build:android || echo "lane 构建失败，尝试 Gradle 兜底…"
      - name: 兜底：直接 Gradle 生成 APK（如 lane 只产出 AAB）
        script: |
          set -e
          cd android
          ./gradlew assembleRelease \
            -Pandroid.injected.signing.store.file="$CM_KEYSTORE_PATH" \
            -Pandroid.injected.signing.store.password="$CM_KEY_PASSWORD" \
            -Pandroid.injected.signing.key.alias="$CM_KEY_ALIAS" \
            -Pandroid.injected.signing.key.password="$CM_KEY_PASSWORD" || true
          cd -
      - name: 收集制品（APK/AAB）
        script: |
          mkdir -p $CM_ARTIFACTS
          find . -type f -name "*release*.apk" -maxdepth 6 -print -exec cp -f {} $CM_ARTIFACTS \; || true
          find . -type f -name "*.aab" -maxdepth 6 -print -exec cp -f {} $CM_ARTIFACTS \; || true

  mm-whitelabel-ios:
    name: Mattermost WhiteLabel iOS (App Store/TestFlight)
    max_build_duration: 120
    instance_type: mac_mini_m2
    environment:
      groups:
        - mm_common
        - jboth_client
        - ios_match
      vars:
        BUILD_FOR_RELEASE: 'true'
        REPLACE_ASSETS: 'true'
        # 兜底强制为 App Store（避免 ad-hoc 冲突）
        GYM_EXPORT_METHOD: app-store
        SIGH_PROFILE_TYPE: app-store
        MATCH_TYPE: appstore
    cache:
      cache_paths:
        - $HOME/Library/Caches/CocoaPods
        - ios/Pods
        - node_modules
    scripts:
      - name: 环境与依赖（Node + watchman + CocoaPods 1.16.1）
        script: |
          set -e
          echo "▶ Using system Node"
          which node || true
          node -v || true
          npm -v || true

          echo "▶ Install watchman（Solidarity 需要）"
          if command -v brew >/dev/null 2>&1; then
            eval "$(/opt/homebrew/bin/brew shellenv)" || true
            brew list watchman >/dev/null 2>&1 || brew install watchman
            watchman --version || true
          else
            echo "❌ Homebrew 未找到，无法安装 watchman"; exit 1
          fi

          echo "▶ Pin CocoaPods 1.16.1（用户 gem 目录）"
          export GEM_HOME="$HOME/.gem"
          export GEM_PATH="$GEM_HOME"
          export PATH="$GEM_HOME/bin:$PATH"
          gem list -i cocoapods -v 1.16.1 || gem install cocoapods -v 1.16.1 --no-document
          unset RUBYOPT BUNDLE_GEMFILE BUNDLE_BIN_PATH BUNDLE_PATH BUNDLER_ORIG_PATH BUNDLER_ORIG_MANPATH || true
          echo "pod path: $(command -v pod || echo 'not found')"
          env -i PATH="$PATH" GEM_HOME="$GEM_HOME" GEM_PATH="$GEM_PATH" HOME="$HOME" LANG="${LANG:-en_US.UTF-8}" pod _1.16.1_ --version

          echo "▶ npm ci"
          npm ci
      - name: Ruby/Fastlane + CocoaPods（用固定的 1.16.1 执行）
        script: |
          set -e
          if command -v rbenv >/dev/null 2>&1; then
            RB_INST="$(rbenv versions --bare | grep -E '^[0-9]+\.[0-9]+' | tail -1 || true)"
            export RBENV_VERSION="${RB_INST:-system}"
            echo "Using rbenv Ruby: ${RBENV_VERSION}"
          fi
          ruby -v || true
          if [ -f .ruby-version ]; then
            mv .ruby-version .ruby-version.bak
            trap 'mv .ruby-version.bak .ruby-version 2>/dev/null || true' EXIT
          fi
          cd ios
          RBENV_VERSION="${RBENV_VERSION}" GEM_HOME="$HOME/.gem" GEM_PATH="$HOME/.gem" HOME="$HOME" LANG="${LANG:-en_US.UTF-8}" pod _1.16.1_ install --repo-update
          cd ..

      - name: 🔧 Patch Pods project（全量移除 *.modulemap 并加固）
        script: |
          set -euo pipefail
          cd ios

          echo "▶ Ruby/xcodeproj 清理所有 target 的 *.modulemap build entries"
          ruby - <<'RUBY'
            require 'xcodeproj'
            proj_path = 'Pods/Pods.xcodeproj'
            abort("Pods project not found at #{proj_path}") unless File.exist?(proj_path)
            proj = Xcodeproj::Project.open(proj_path)

            total_removed = 0

            proj.targets.each do |t|
              # 遍历所有可能的 Build Phases
              phases = []
              phases << t.sources_build_phase     if t.respond_to?(:sources_build_phase)     && t.sources_build_phase
              phases << t.headers_build_phase     if t.respond_to?(:headers_build_phase)     && t.headers_build_phase
              phases << t.resources_build_phase   if t.respond_to?(:resources_build_phase)   && t.resources_build_phase
              phases << t.frameworks_build_phase  if t.respond_to?(:frameworks_build_phase)  && t.frameworks_build_phase
              phases += t.copy_files_build_phases if t.respond_to?(:copy_files_build_phases) && t.copy_files_build_phases
              phases.compact!
              phases.flatten!

              phases.each do |phase|
                # 先收集，后删除，避免遍历中修改
                to_remove = phase.files.select do |bf|
                  fr = bf.file_ref
                  fr && fr.path && fr.path.end_with?('.modulemap')
                end
                to_remove.each do |bf|
                  phase.remove_build_file(bf)
                end
                total_removed += to_remove.size

                # 额外：某些 xcodeproj 版本需要移除 dangling 的 files_references
                if phase.respond_to?(:files_references)
                  phase.files_references.select { |fr| (fr.path || '').end_with?('.modulemap') }
                       .each { |fr| phase.remove_file_reference(fr) }
                end
              end

              # 针对每个配置加固排除规则，防止未来被误收录
              t.build_configurations.each do |cfg|
                bs = cfg.build_settings
                cur = bs['EXCLUDED_SOURCE_FILE_NAMES']
                list = Array(cur).flat_map { |e| e.to_s.split(/\s+/) }
                list |= ['*.modulemap', '*/module.modulemap']
                bs['EXCLUDED_SOURCE_FILE_NAMES'] = list.join(' ')
                bs['DEFINES_MODULE'] = 'YES'
                bs['CLANG_USE_MODULES'] = 'YES'
              end
            end

            proj.save
            puts "✅ Removed #{total_removed} .modulemap build entries across all Pods targets"
          RUBY

          # —— 终极兜底：如果还有某些 phase 在解析路径，直接把该文件改个后缀，避免被识别为 modulemap ——
          FILE="Pods/TurboLogIOSNative/Sources/TurboLogSwift/module.modulemap"
          if [ -f "$FILE" ]; then
            echo "▶ 兜底改名：$FILE -> ${FILE}.disabled"
            mv "$FILE" "${FILE}.disabled"
          fi

          cd ..


      - name: 强制 gym 导出为 App Store（修补 Fastfile）
        script: |
          set -euo pipefail
          FF="fastlane/Fastfile"
          if [ -f "$FF" ]; then
            echo "▶ Patching $FF export_method -> app-store"
            perl -0777 -pe "s/export_method:\s*['\"]ad-?hoc['\"]/export_method: 'app-store'/g" -i "$FF"
            perl -0777 -pe "s/export_method:\s*:ad_?hoc/export_method: :app_store/g" -i "$FF"
            echo "✅ Fastfile patched"
          else
            echo "ℹ️ No Fastfile at $FF, skipping"
          fi
          export GYM_EXPORT_METHOD=app-store
          export SIGH_PROFILE_TYPE=app-store
          export MATCH_TYPE=appstore
      - name: 配置证书库（HTTPS+Token）并自检
        script: |
          set -e
          if [ -z "${GITHUB_PAT:-}" ]; then echo '❌ 缺少 GITHUB_PAT'; exit 1; fi
          export MATCH_GIT_URL="https://${GITHUB_PAT}@github.com/goodwillworld/ios-certs.git"
          echo 'MATCH_GIT_URL set (token masked)'
          git -c credential.helper= ls-remote "$MATCH_GIT_URL" >/dev/null
          echo '✅ match 证书库可访问'
          export SIGH_GIT_URL="$MATCH_GIT_URL"
      - name: 生成 ASC API Key（供 match/gym 使用）
        script: |
          set -e
          : "${ASC_KEY_ID:?缺少 ASC_KEY_ID}"
          : "${ASC_ISSUER_ID:?缺少 ASC_ISSUER_ID}"
          : "${ASC_PRIVATE_KEY:?缺少 ASC_PRIVATE_KEY}"
          python3 - <<'PY'
          import os, json, sys
          kid=os.environ["ASC_KEY_ID"].strip()
          iid=os.environ["ASC_ISSUER_ID"].strip()
          key=os.environ["ASC_PRIVATE_KEY"].replace("\r\n","\n").replace("\r","\n")
          data={"key_id":kid,"issuer_id":iid,"key":key,"in_house":False}
          open("asc_api_key.json","w").write(json.dumps(data))
          PY
          python3 -m json.tool asc_api_key.json >/dev/null && echo "✅ asc_api_key.json OK"
      - name: 拉取 App Store 描述文件（readonly）
        script: |
          set -e
          if [ -f Gemfile ] && grep -qi 'fastlane' Gemfile; then
            gem install bundler --no-document
            bundle install
            FL="bundle exec fastlane"
          else
            gem install fastlane -v 2.228.0 --no-document || gem install fastlane --no-document
            FL="fastlane"
          fi
          $FL --version
          KEYCHAIN_PWD="${KEYCHAIN_PWD:-$(uuidgen)}"
          $FL run create_keychain name:"cm_tmp" password:"$KEYCHAIN_PWD" default_keychain:true unlock:true timeout:3600
          $FL run match \
            type:"appstore" \
            readonly:"true" \
            git_url:"$MATCH_GIT_URL" \
            team_id:"$FASTLANE_TEAM_ID" \
            api_key_path:"asc_api_key.json" \
            keychain_name:"cm_tmp" \
            keychain_password:"$KEYCHAIN_PWD" \
            verbose:true
      
      - name: Patch Fastfile（强制 gym 使用 app-store 导出）
        script: |
          set -euo pipefail
          F=fastlane/Fastfile
          if [ -f "$F" ]; then
            # 1) 将显式写死的 export_method: "ad-hoc" 改为 "app-store"
            /usr/bin/ruby - <<'RUBY'
              f = 'fastlane/Fastfile'
              s = File.read(f)
              # 标准写法 gym(export_method: "ad-hoc")
              s.gsub!(/export_method:\s*["']ad-?hoc["']/i, 'export_method: "app-store"')
              # 如果是用 options 哈希传入（如 export_options.method）
              s.gsub!(/(export_options\.\s*method\s*=>\s*|export_options\.\s*method:\s*)["']ad-?hoc["']/i, '\1"app-store"')
              # 如果 Fastfile 从 ENV 读值，则确保默认是 app-store
              s.gsub!(/ENV\[['"]GYM_EXPORT_METHOD['"]\]\s*\|\|\s*["']ad-?hoc["']/i, 'ENV["GYM_EXPORT_METHOD"] || "app-store"')
              File.write(f, s)
              puts "✅ Patched export_method to app-store in #{f}"
            RUBY

            # 2) 兜底：设置环境变量（若 Fastfile 未显式指定，将采用此值）
            export GYM_EXPORT_METHOD=app-store
            export SIGH_PROFILE_TYPE=app-store

            # 3) 打印一下以便确认
            echo "GYM_EXPORT_METHOD=$GYM_EXPORT_METHOD"
            echo "SIGH_PROFILE_TYPE=$SIGH_PROFILE_TYPE"
          else
            echo "⚠️ 未找到 fastlane/Fastfile，跳过补丁"
          fi


      - name: 构建 iOS（使用仓库 lane）
        script: |
          set -e
          npm run build:ios
      - name: 收集制品
        script: |
          mkdir -p $CM_ARTIFACTS
          find . -type f -name "*.ipa" -maxdepth 6 -print -exec cp -f {} $CM_ARTIFACTS \; || true
    publishing:
      app_store_connect:
        api_key: $ASC_PRIVATE_KEY
        key_id: $ASC_KEY_ID
        issuer_id: $ASC_ISSUER_ID
        submit_to_testflight: true
