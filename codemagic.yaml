workflows:
  # ========= ANDROID：白标 + 生成 APK（自行分发），不发布到商店 =========
  mm-whitelabel-android-sideload:
    name: Mattermost WhiteLabel ANDROID (sideload)
    max_build_duration: 120
    instance_type: linux_x2
    environment:
      android_signing:
        - jboth_android_keystore_ref   # 在 Team settings → codemagic.yaml settings → Code signing identities 上传后得到的引用名
      groups:
        - mm_common                    # 通用变量组：REPLACE_ASSETS、APP_SCHEME、等
        - jboth_client                 # 客户变量组：APP_NAME、MAIN_APP_IDENTIFIER 等
      vars:
        BUILD_FOR_RELEASE: "true"
        ANDROID_BUILD_TASK: "assemble" # assemble=APK；bundle=AAB
        REPLACE_ASSETS: "true"
    cache:
      cache_paths:
        - $HOME/.gradle/caches
        - node_modules
    scripts:
      - name: Node 环境与依赖
        script: |
          set -e
          if [ -f ".nvmrc" ]; then . $HOME/.nvm/nvm.sh && nvm install && nvm use; fi
          npm ci

      - name: 注入签名（Gradle）
        script: |
          mkdir -p $HOME/.gradle
          cat >> $HOME/.gradle/gradle.properties <<EOF
          MATTERMOST_RELEASE_STORE_FILE=$CM_KEYSTORE_PATH
          MATTERMOST_RELEASE_KEY_ALIAS=$CM_KEY_ALIAS
          MATTERMOST_RELEASE_PASSWORD=$CM_KEY_PASSWORD
          EOF

      - name: 写入/兜底默认服务器配置（如仓库中已存在将不会覆盖）
        script: |
          set -e
          mkdir -p assets/override
          CFG=assets/override/config.json
          if [ ! -f "$CFG" ]; then
            cat > "$CFG" <<'JSON'
          {
            "DefaultServerUrl": "https://hello.jboth.com",
            "AutoSelectServerUrl": true
          }
          JSON
            echo "Created $CFG with default server URL."
          else
            echo "Found existing $CFG, keep your repo version."
          fi

      - name: 白标变量确认
        script: |
          echo "APP_NAME=$APP_NAME"
          echo "MAIN_APP_IDENTIFIER=$MAIN_APP_IDENTIFIER"
          echo "APP_SCHEME=$APP_SCHEME"

      - name: 构建（优先使用仓库自带 lane）
        script: |
          set -e
          npm run build:android || echo "lane 构建失败，尝试 Gradle 兜底…"

      - name: 兜底：直接 Gradle 生成 APK（如 lane 只产出 AAB）
        script: |
          set -e
          cd android
          ./gradlew assembleRelease \
            -Pandroid.injected.signing.store.file="$CM_KEYSTORE_PATH" \
            -Pandroid.injected.signing.store.password="$CM_KEY_PASSWORD" \
            -Pandroid.injected.signing.key.alias="$CM_KEY_ALIAS" \
            -Pandroid.injected.signing.key.password="$CM_KEY_PASSWORD" || true
          cd -

      - name: 收集制品（APK/AAB）
        script: |
          mkdir -p $CM_ARTIFACTS
          find . -type f -name "*release*.apk" -maxdepth 6 -print -exec cp -f {} $CM_ARTIFACTS \; || true
          find . -type f -name "*.aab" -maxdepth 6 -print -exec cp -f {} $CM_ARTIFACTS \; || true
    # 不写 publishing：仅在 Artifacts 输出安装包

  # ========= iOS：白标 + TestFlight/App Store 分发（用 api_key_path 方案） =========
  mm-whitelabel-ios:
    name: Mattermost WhiteLabel iOS (TestFlight/App Store)
    max_build_duration: 120
    instance_type: mac_mini_m2

    # 可选：即使配置了 integrations，publishing 用的是 api_key_path，不冲突
    # integrations:
    #   app_store_connect: codemagic

    environment:
      groups:
        - mm_common
        - jboth_client
        - ios_match
      vars:
        BUILD_FOR_RELEASE: "true"
        REPLACE_ASSETS: "true"
        # 变量组里需提供：
        # APP_NAME、MAIN_APP_IDENTIFIER、
        # EXTENSION_APP_IDENTIFIER、NOTIFICATION_SERVICE_IDENTIFIER、
        # FASTLANE_TEAM_ID、IOS_APP_GROUP、IOS_ICLOUD_CONTAINER、
        # MATCH_USERNAME、MATCH_PASSWORD、MATCH_GIT_URL、MATCH_APP_IDENTIFIER、MATCH_TYPE=appstore、SYNC_PROVISIONING_PROFILES=true
        # 以及 ASC_KEY_ID、ASC_ISSUER_ID、ASC_PRIVATE_KEY（App 或 Team 级环境变量，设为 Secret）

    cache:
      cache_paths:
        - $HOME/Library/Caches/CocoaPods
        - ios/Pods
        - node_modules

    scripts:
      # 若你的 match 仓库是自建域名，可取消注释预热 known_hosts
      # - name: SSH known_hosts
      #   script: |
      #     mkdir -p ~/.ssh && ssh-keyscan your.git.host >> ~/.ssh/known_hosts

      - name: 环境与依赖（Node）
        script: |
          set -e

          echo "▶ Using system Node"
          which node || true
          node -v
          npm -v

          echo "▶ Install watchman (solidarity requires it)"
          if command -v brew >/dev/null 2>&1; then
            eval "$(/opt/homebrew/bin/brew shellenv)" || true
            brew list watchman >/dev/null 2>&1 || brew install watchman
            watchman --version || true
          else
            echo "❌ Homebrew 未找到，无法安装 watchman"
            exit 1
          fi

          echo "▶ Pin CocoaPods to 1.16.1 (user gem dir) and bypass Bundler"
          # 安装到用户目录，避免动系统 Ruby/Gems
          export GEM_HOME="$HOME/.gem"
          export GEM_PATH="$GEM_HOME"
          export PATH="$GEM_HOME/bin:$PATH"
          gem list -i cocoapods -v 1.16.1 || gem install cocoapods -v 1.16.1 --no-document

          # 彻底规避 Bundler 注入：清掉相关环境变量，再用 RubyGems 的“可执行版本”语法
          unset RUBYOPT BUNDLE_GEMFILE BUNDLE_BIN_PATH BUNDLE_PATH BUNDLER_ORIG_PATH BUNDLER_ORIG_MANPATH || true
          echo "pod path: $(command -v pod || echo 'not found')"
          env -i PATH="$PATH" GEM_HOME="$GEM_HOME" GEM_PATH="$GEM_PATH" HOME="$HOME" LANG="${LANG:-en_US.UTF-8}" pod _1.16.1_ --version

          echo "▶ npm ci"
          npm ci

      - name: Ruby/CocoaPods/Fastlane
        script: |
          gem install bundler --no-document
          bundle install
          cd ios && bundle exec pod install --repo-update && cd ..

      # —— 关键：在 match 之前配置 SSH，并自检访问证书库 ——
      - name: 配置证书库（HTTPS + Token）并自检
        script: "set -e; if [ -z \"${GITHUB_PAT:-}\" ]; then echo '❌ 缺少 GITHUB_PAT'; exit 1; fi; export MATCH_GIT_URL=\"https://${GITHUB_PAT}@github.com/goodwillworld/ios-certs.git\"; echo 'MATCH_GIT_URL set (token masked)'; git -c credential.helper= ls-remote \"$MATCH_GIT_URL\" >/dev/null; echo '✅ match 证书库可访问（HTTPS+Token）'; export SIGH_GIT_URL=\"$MATCH_GIT_URL\""

      - name: 自检关键变量（不会泄露）
        script: |
          set -e
          check_var() { if [ -z "${!1}" ]; then echo "❌ MISSING $1"; exit 1; else echo "✅ $1 OK"; fi; }
          check_var FASTLANE_TEAM_ID
          check_var MATCH_USERNAME
          check_var MATCH_PASSWORD
          check_var MATCH_GIT_URL
          check_var MATCH_APP_IDENTIFIER
          check_var MATCH_TYPE
          check_var ASC_KEY_ID
          check_var ASC_ISSUER_ID
          if [ -z "$ASC_PRIVATE_KEY" ]; then echo "❌ MISSING ASC_PRIVATE_KEY"; exit 1; else echo "✅ ASC_PRIVATE_KEY OK (hidden)"; fi

      - name: 诊断并预先拉取 match 仓库（HTTPS+Token，自动安装 fastlane）
        script: |
          set -e

          # 0) 基础变量检查（这几个必须有）
          : "${MATCH_USERNAME:?缺少 MATCH_USERNAME(Apple ID)}"
          : "${MATCH_PASSWORD:?缺少 MATCH_PASSWORD(match加密口令)}"
          : "${FASTLANE_TEAM_ID:?缺少 FASTLANE_TEAM_ID}"
          : "${MATCH_APP_IDENTIFIER:?缺少 MATCH_APP_IDENTIFIER}"

          # 1) 证书库地址（优先用已有的 MATCH_GIT_URL；没有就用 GITHUB_PAT 组装 HTTPS 地址）
          if [ -z "${MATCH_GIT_URL:-}" ]; then
            : "${GITHUB_PAT:?缺少 GITHUB_PAT 或 MATCH_GIT_URL}"
            export MATCH_GIT_URL="https://${GITHUB_PAT}@github.com/goodwillworld/ios-certs.git"
          fi
          export SIGH_GIT_URL="$MATCH_GIT_URL"   # 防止被 Matchfile 覆盖

          echo "MATCH_GIT_URL set (token masked)"

          # 2) 自检：证书库可访问（用 HTTPS+Token）
          git -c credential.helper= ls-remote "$MATCH_GIT_URL" >/dev/null
          echo "✅ match 证书库可访问（HTTPS+Token）"

          # 3) 安装 fastlane（按需）
          if [ -f Gemfile ] && grep -qi 'fastlane' Gemfile; then
            echo "▶ Gemfile 检测到 fastlane，使用 bundler"
            gem install bundler --no-document
            bundle install
            FASTLANE="bundle exec fastlane"
          else
            echo "▶ 未检测到 Gemfile 中的 fastlane，直接安装 gem"
            gem install fastlane -v 2.228.0 --no-document || gem install fastlane --no-document
            FASTLANE="fastlane"
          fi
          $FASTLANE --version

          # 4) 预拉取并解密证书（readonly=true 不会改动远端）
          #    若你的证书库已经用 match 初始化过，这一步会用 MATCH_PASSWORD 解密
          $FASTLANE run match \
            type:"appstore" \
            readonly:"true" \
            git_url:"$MATCH_GIT_URL" \
            app_identifier:"$MATCH_APP_IDENTIFIER" \
            team_id:"$FASTLANE_TEAM_ID" \
            verbose:true

      - name: 首次初始化签名（仅当证书库为空时执行）
        script: |
          set -e

          # 0) 必要变量
          : "${MATCH_GIT_URL:?缺少 MATCH_GIT_URL（已用 HTTPS+Token 自检通过）}"
          : "${FASTLANE_TEAM_ID:?缺少 FASTLANE_TEAM_ID}"
          : "${MATCH_APP_IDENTIFIER:?缺少 MATCH_APP_IDENTIFIER（可逗号分隔多个ID）}"
          : "${ASC_KEY_ID:?缺少 ASC_KEY_ID}"
          : "${ASC_ISSUER_ID:?缺少 ASC_ISSUER_ID}"
          : "${ASC_PRIVATE_KEY:?缺少 ASC_PRIVATE_KEY}"

          # 1) 检测仓库是否为空（无任何分支）
          if [ "$(git -c credential.helper= ls-remote --heads "$MATCH_GIT_URL" | wc -l | tr -d ' ')" -gt 0 ]; then
            echo "ℹ️ 证书库非空，跳过初始化（将沿用已有证书/描述文件）"
            exit 0
          fi
          echo "🆕 检测到空仓库：执行首轮初始化（创建证书/描述文件并 push）"

          # 2) 准备 fastlane（有 Gemfile 就用 bundler，没有就 gem 安装）
          if [ -f Gemfile ] && grep -qi 'fastlane' Gemfile; then
            gem install bundler --no-document
            bundle install
            FL="bundle exec fastlane"
          else
            gem install fastlane -v 2.228.0 --no-document || gem install fastlane --no-document
            FL="fastlane"
          fi
          $FL --version

          # 3) 生成 ASC API Key JSON（供 match 使用）
          cat > asc_api_key.json <<EOF
          {
            "key_id":    "${ASC_KEY_ID}",
            "issuer_id": "${ASC_ISSUER_ID}",
            "key":       "${ASC_PRIVATE_KEY}",
            "in_house":  false
          }
          EOF

          # 4) 建一个临时 keychain（避免系统钥匙串交互）
          KEYCHAIN_PWD="${KEYCHAIN_PWD:-$(uuidgen)}"
          $FL run create_keychain name:"cm_tmp" password:"$KEYCHAIN_PWD" default_keychain:true unlock:true timeout:3600

          # 5) 设定 git 用户信息（便于 push 首次提交）
          git config --global user.email "codemagic@local"
          git config --global user.name  "Codemagic CI"

          # 6) 用 App Store Connect API Key 首次创建（只这一次 readonly:false）
          $FL run match \
            type:"appstore" \
            readonly:"false" \
            git_url:"$MATCH_GIT_URL" \
            app_identifier:"$MATCH_APP_IDENTIFIER" \
            team_id:"$FASTLANE_TEAM_ID" \
            api_key_path:"asc_api_key.json" \
            keychain_name:"cm_tmp" \
            keychain_password:"$KEYCHAIN_PWD" \
            verbose:true

          echo "✅ 首次初始化完成：后续构建可改回 readonly:true"


      # - name: 生成 App Store Connect API Key JSON（供 publishing 使用）
            #   script: |
            #     set -e
            #     cat > asc_api_key.json <<EOF
            #     {
            #       "key_id": "${ASC_KEY_ID}",
            #       "issuer_id": "${ASC_ISSUER_ID}",
            #       "key": "${ASC_PRIVATE_KEY}",
            #       "in_house": false
            #     }
            #     EOF
            #     echo "✅ asc_api_key.json generated"
      - name: 构建 iOS（使用仓库 lane）
        script: |
          npm run build:ios
      - name: 收集制品
        script: |
          mkdir -p $CM_ARTIFACTS
          find . -type f -name "*.ipa" -maxdepth 6 -print -exec cp -f {} $CM_ARTIFACTS \; || true
    publishing:
      app_store_connect:
        api_key: |
          -----BEGIN PRIVATE KEY-----
          MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgTHFCUEmtmzuEaG/T
          zD5C5EBtEBsuWf54ZxCbWmpD/lugCgYIKoZIzj0DAQehRANCAAS6nYsA0zoFzGbY
          t9rYpOKdcq0hG8zmImfhjOct0m609Z/J4fOcoxeLd3LJr4DAo6Kk+PBeCFBvrxIl
          j5J7JvfX
          -----END PRIVATE KEY-----
        key_id: "UZ33M397NY"
        issuer_id: "26e601c9-c2f0-497a-a9e1-39a426cecf9a"
        submit_to_testflight: true