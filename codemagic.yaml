workflows:
  # ========= ANDROID：白标 + 生成 APK（自行分发），不发布到商店 =========
  mm-whitelabel-android-sideload:
    name: Mattermost WhiteLabel ANDROID (sideload)
    max_build_duration: 120
    instance_type: linux_x2
    environment:
      android_signing:
        # 在 Codemagic > Code signing identities 上传 keystore 后，填你的引用名
        - jboth_android_keystore_ref
      groups:
        - mm_common      # 通用白标变量组（见下文）
        - jboth_client   # 客户/品牌变量组（见下文）
      vars:
        BUILD_FOR_RELEASE: "true"
        ANDROID_BUILD_TASK: "assemble"    # assemble=APK；bundle=AAB
        REPLACE_ASSETS: "true"
    cache:
      cache_paths:
        - $HOME/.gradle/caches
        - node_modules
    scripts:
      - name: Node 环境与依赖
        script: |
          set -e
          if [ -f ".nvmrc" ]; then . $HOME/.nvm/nvm.sh && nvm install && nvm use; fi
          npm ci
      - name: 注入签名（Gradle）
        script: |
          mkdir -p $HOME/.gradle
          cat >> $HOME/.gradle/gradle.properties <<EOF
          MATTERMOST_RELEASE_STORE_FILE=$CM_KEYSTORE_PATH
          MATTERMOST_RELEASE_KEY_ALIAS=$CM_KEY_ALIAS
          MATTERMOST_RELEASE_PASSWORD=$CM_KEY_PASSWORD
          EOF
      - name: 写入/兜底默认服务器配置（如仓库中已存在将不会覆盖）
        script: |
          set -e
          mkdir -p assets/override
          CFG=assets/override/config.json
          if [ ! -f "$CFG" ]; then
            cat > "$CFG" <<'JSON'
          {
            "DefaultServerUrl": "https://hello.jboth.com",
            "AutoSelectServerUrl": true
          }
          JSON
            echo "Created $CFG with default server URL."
          else
            echo "Found existing $CFG, keep your repo version."
          fi
      - name: 白标变量确认
        script: |
          echo "APP_NAME=$APP_NAME"
          echo "MAIN_APP_IDENTIFIER=$MAIN_APP_IDENTIFIER"
          echo "APP_SCHEME=$APP_SCHEME"
      - name: 构建（优先使用仓库自带 lane）
        script: |
          set -e
          npm run build:android || echo "lane 构建失败，尝试 Gradle 兜底…"
      - name: 兜底：直接 Gradle 生成 APK（如 lane 只产出 AAB）
        script: |
          set -e
          cd android
          ./gradlew assembleRelease \
            -Pandroid.injected.signing.store.file="$CM_KEYSTORE_PATH" \
            -Pandroid.injected.signing.store.password="$CM_KEY_PASSWORD" \
            -Pandroid.injected.signing.key.alias="$CM_KEY_ALIAS" \
            -Pandroid.injected.signing.key.password="$CM_KEY_PASSWORD" || true
          cd -
      - name: 收集制品（APK/AAB）
        script: |
          mkdir -p $CM_ARTIFACTS
          find . -type f -name "*release*.apk" -maxdepth 6 -print -exec cp -f {} $CM_ARTIFACTS \; || true
          find . -type f -name "*.aab" -maxdepth 6 -print -exec cp -f {} $CM_ARTIFACTS \; || true
    # 不写 publishing：仅在 Artifacts 输出安装包，便于你自行分发

workflows:
  # ……(你的 ANDROID workflow 保持原样)……

  mm-whitelabel-ios:
    name: Mattermost WhiteLabel iOS (TestFlight/App Store)
    max_build_duration: 120
    instance_type: mac_mini_m2

    # 集成可保留（可选）。即便配置了 integrations，publishing 里的 api_key 也会生效。
    integrations:
      app_store_connect: codemagic   # 如无此集成可保留/删除均可

    environment:
      groups:
        - mm_common
        - jboth_client
        - ios_match
      vars:
        BUILD_FOR_RELEASE: "true"
        REPLACE_ASSETS: "true"
        # 需要在变量组里提供：
        # APP_NAME、MAIN_APP_IDENTIFIER、
        # EXTENSION_APP_IDENTIFIER、NOTIFICATION_SERVICE_IDENTIFIER、
        # FASTLANE_TEAM_ID、IOS_APP_GROUP、IOS_ICLOUD_CONTAINER、MATCH_* 等

    cache:
      cache_paths:
        - $HOME/Library/Caches/CocoaPods
        - ios/Pods
        - node_modules

    scripts:
      # （可选）如果你的 match 仓库是私有自建域名，预热 known_hosts
      # - name: SSH known_hosts
      #   script: |
      #     mkdir -p ~/.ssh && ssh-keyscan your.git.host >> ~/.ssh/known_hosts

      - name: 环境与依赖（Node）
        script: |
          set -e
          if [ -f ".nvmrc" ]; then . $HOME/.nvm/nvm.sh && nvm install && nvm use; fi
          npm ci

      - name: Ruby/CocoaPods/Fastlane
        script: |
          gem install bundler --no-document
          bundle install
          cd ios && bundle exec pod install --repo-update && cd ..

      # 自检：检查关键变量是否存在（不打印密钥内容）
      - name: 自检关键变量（不会泄露）
        script: |
          set -e
          check_var() { if [ -z "${!1}" ]; then echo "❌ MISSING $1"; exit 1; else echo "✅ $1 OK"; fi; }
          check_var FASTLANE_TEAM_ID
          check_var MATCH_USERNAME
          check_var MATCH_PASSWORD
          check_var MATCH_GIT_URL
          check_var MATCH_APP_IDENTIFIER
          check_var MATCH_TYPE
          # App Store Connect API Key 三件套
          check_var ASC_KEY_ID
          check_var ASC_ISSUER_ID
          # 只检查是否有值，不回显私钥
          if [ -z "$ASC_PRIVATE_KEY" ]; then echo "❌ MISSING ASC_PRIVATE_KEY"; exit 1; else echo "✅ ASC_PRIVATE_KEY OK (hidden)"; fi

      - name: 构建 iOS（使用仓库 lane）
        script: |
          npm run build:ios

      - name: 收集制品
        script: |
          mkdir -p $CM_ARTIFACTS
          find . -type f -name "*.ipa" -maxdepth 6 -print -exec cp -f {} $CM_ARTIFACTS \; || true

    # ✅ 这里是关键：使用 API Key 直接在 YAML 里提供（方案 B）
    publishing:
      app_store_connect:
        api_key:
          key_id: $ASC_KEY_ID          # 例：1A2BC3D4E5
          issuer_id: $ASC_ISSUER_ID    # 例：12345678-90ab-cdef-1234-567890abcdef
          key: $ASC_PRIVATE_KEY        # 把 .p8 原文粘贴到变量里（含 BEGIN/END 与换行）
        submit_to_testflight: true
        # 如需直接上架，取消注释：
        # submit_to_app_store: true
        # beta_groups:
        #   - Internal Testers

