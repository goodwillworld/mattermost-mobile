workflows:
  ios-mattermost-release:
    name: iOS Mattermost (whitelabel) — up to pods
    instance_type: mac_mini_m2
    max_build_duration: 120
    environment:
      vars:
        # 你的白标 App 基本变量（后续签名/打包会用到；本阶段不强依赖）
        APP_BUNDLE_ID: com.jboth.mine
        SHARE_BUNDLE_ID: com.jboth.mine.MattermostShare
        NOTIF_BUNDLE_ID: com.jboth.mine.NotificationService
        APP_GROUP_ID: group.com.jboth.mine
        APP_IOS_DEPLOYMENT_TARGET: "15.1"

      xcode: 16.4
      cocoapods: 1.15.2
      node: 20.11.1
      npm: 10.8.2

      # 缓存能显著加快 pod & npm
      cache:
        cache_paths:
          - $HOME/Library/Caches/CocoaPods
          - ios/Pods
          - $CM_BUILD_DIR/node_modules
          - $HOME/Library/Caches/npm/_cacache

    triggering:
      events:
        - push
      branch_patterns:
        - pattern: "*"
          include: true
          source: true

    scripts:
      # ---- 0) 基础环境可见性 ----
      - name: Show toolchain versions
        script: |
          set -euo pipefail
          sw_vers
          xcodebuild -version
          ruby -v
          pod --version
          node -v
          npm -v

      # ---- 1) Node 源与 npm 行为：锁定官方源，严格但避免 ci EUSAGE ----
      - name: NPM registry & config
        script: |
          set -euo pipefail
          echo "registry=https://registry.npmjs.org/" > .npmrc
          npm config set registry https://registry.npmjs.org/
          npm config set fund false
          npm config set audit false
          npm config set progress false

      # ---- 2) 修正 package.json：把问题依赖钉到“存在且兼容”的版本 ----
      # 说明：
      #  - 我们先改 package.json（overrides + 同步到各依赖段）
      #  - 再“只生成/刷新 lock”以保证 lock 与 package.json 完全一致
      #  - 最后执行 npm install（不使用 npm ci，从根上杜绝 EUSAGE）
      - name: Fix JS deps to known-good set & write lock
        script: |
          set -euo pipefail
          node - <<'NODE'
          const fs = require('fs');
          const path = 'package.json';
          const pkg = JSON.parse(fs.readFileSync(path, 'utf8'));

          // 一组“已确认存在”的版本，避免 ETARGET / notarget
          const pins = {
            "eslint": "8.57.1",            // 兼容 @typescript-eslint@7
            "yaml": "2.4.5",               // 2.4.1 不存在 → 2.4.5
            "ws": "7.5.9",                 // 7.5.10 不存在 → 7.5.9
            "set-function-length": "1.2.1" // 1.2.2 不存在 → 1.2.1
          };

          // merges to overrides
          pkg.overrides = Object.assign({}, pkg.overrides || {}, pins);

          // 同步到各依赖段（若本来已声明）
          for (const sect of ["dependencies","devDependencies","optionalDependencies","peerDependencies"]) {
            if (!pkg[sect]) continue;
            for (const k of Object.keys(pins)) {
              if (pkg[sect][k]) pkg[sect][k] = pins[k];
            }
          }

          fs.writeFileSync(path, JSON.stringify(pkg, null, 2));
          console.log('Pinned overrides:', pins);
          NODE

          # 只生成/刷新 lock（不安装）
          npm install --package-lock-only --ignore-scripts --no-audit

          # 兜底修正（如果历史 lock 中仍遗留了不存在的版本号）
          if [ -f package-lock.json ]; then
            sed -i.bak 's/"yaml": "2\.4\.1"/"yaml": "2.4.5"/g' package-lock.json || true
            sed -i.bak 's/"ws": "7\.5\.10"/"ws": "7.5.9"/g'  package-lock.json || true
            sed -i.bak 's/"set-function-length": "1\.2\.2"/"set-function-length": "1.2.1"/g' package-lock.json || true
          fi

      # ---- 3) 安装 JS 依赖（不用 npm ci，避免你之前的 EUSAGE）----
      - name: Install JS deps (no ci, lock-first)
        script: |
          set -euo pipefail
          # 再保险：确保 lock 存在
          if [ ! -f package-lock.json ]; then
            npm install --package-lock-only --ignore-scripts --no-audit
          fi
          npm install --ignore-scripts --no-audit

      # ---- 4) CocoaPods：Podfile 预修正（兼容 RN 解析 & 统一 Swift 版本）----
      - name: Prepare Podfile (safe resolver + Swift unification)
        script: |
          set -euo pipefail
          P=ios/Podfile
          test -f "$P"

          # ①：安全 require（支持 Node hoisting 的解析方式）
          ruby - <<'RUBY'
          path = 'ios/Podfile'
          s = File.read(path)

          # 如果没定义 node 解析函数，插入一个
          unless s.include?("def node_require(")
            inject = <<~'HEAD'
            def node_require(script)
              # Resolve script with node to allow for hoisting
              require Pod::Executable.execute_command('node', ['-p',
                "require.resolve(
                  '\#{script}',
                  {paths: [process.argv[1]]},
                )", __dir__]).strip
            end

            # --- SAFE Expo autolinking (only if Expo is installed) ---
            expo_pkg = `node -e "try{console.log(require.resolve('expo/package.json'))}catch(e){}"`.strip
            if !expo_pkg.empty? && File.exist?(File.join(File.dirname(expo_pkg), "scripts/autolinking.rb"))
              require File.join(File.dirname(expo_pkg), "scripts/autolinking")
              $expo_modules_available = true
            else
              Pod::UI.puts "Expo not detected; skipping Expo autolinking.".yellow
              $expo_modules_available = false
              def use_expo_modules!(*args); end
            end

            node_require('react-native/scripts/react_native_pods.rb')
            node_require('react-native-permissions/scripts/setup.rb')
            HEAD
            s = inject + "\n" + s
          end

          # ②：platform 至少 15.1（兼容现有白标），如已存在则不动
          unless s =~ /^\s*platform\s+:ios,/
            s = s.sub(/^/, "platform :ios, '15.1'\n")
          end

          File.write(path, s)
          puts "Podfile base prepared."
          RUBY

          # ③：注入 pre_install: 统一所有 Pods 的 swift_version=5.9，避免
          #     "[!] There may only be up to 1 unique SWIFT_VERSION per target" 报错
          ruby - <<'RUBY'
          path = 'ios/Podfile'
          s = File.read(path)

          pre_blk = <<~'PRE'
          pre_install do |installer|
            installer.pod_targets.each do |pod|
              # 强制每个 Pod 的 Swift 版本为 5.9
              begin
                pod.swift_version = '5.9'
              rescue
                # 某些旧 CocoaPods 可能无此属性，忽略
              end
            end
          end
          PRE

          if s.include?('pre_install do |installer|')
            # 已存在就不重复注入
            puts "pre_install present, skip inject."
          else
            s << "\n" + pre_blk + "\n"
            File.write(path, s)
            puts "Injected pre_install to unify Swift versions."
          end
          RUBY

      # ---- 5) Pod repo 更新 + 安装 ----
      - name: Install pods
        script: |
          set -euo pipefail
          cd ios
          pod repo update
          # 用 --verbose 便于排错；若你觉得太吵，可移除
          pod install --verbose

    # 本工作流只需要跑到安装 Pods 成功即可，所以下面不打包
    # artifacts / publishing 略

      # # --- 5) pod install ---
      # - name: Install pods (with repo update)
      #   script: |
      #     set -euo pipefail
      #     pushd ios >/dev/null
      #     pod repo update
      #     pod install --repo-update
      #     popd >/dev/null

      # --- 6) 注入 Entitlements（App Group + aps-environment=production）---
      - name: Ensure entitlements (App Group & aps)
        script: |
          set -euo pipefail
          E_APP="ios/Mattermost/Mattermost.entitlements"
          E_SHARE="ios/MattermostShare/MattermostShare.entitlements"
          E_NOTIF="ios/NotificationService/NotificationService.entitlements"

          for E in "$E_APP" "$E_SHARE" "$E_NOTIF"; do
            /usr/libexec/PlistBuddy -c "Add :com.apple.security.application-groups array" "$E" 2>/dev/null || true
            /usr/libexec/PlistBuddy -c "Delete :com.apple.security.application-groups" "$E" 2>/dev/null || true
            /usr/libexec/PlistBuddy -c "Add :com.apple.security.application-groups array" "$E"
            /usr/libexec/PlistBuddy -c "Add :com.apple.security.application-groups:0 string $APP_GROUP" "$E"
          done

          # 主 app 需要 push
          /usr/libexec/PlistBuddy -c "Set :aps-environment production" "$E_APP" 2>/dev/null || \
          /usr/libexec/PlistBuddy -c "Add :aps-environment string production" "$E_APP"

          echo "Entitlements updated."

      # --- 7) 安装/拷贝 Provisioning Profiles（来自 Secure files）---
      # 把 3 个 .mobileprovision 作为 Secure files 关联到该工作流即可（名字不限）
      - name: Install provisioning profiles
        script: |
          set -euo pipefail
          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          for f in *.mobileprovision; do
            if [ -f "$f" ]; then
              cp "$f" "$HOME/Library/MobileDevice/Provisioning Profiles/$(basename "$f")"
              echo "Installed profile: $f"
            fi
          done
          ls -l "$HOME/Library/MobileDevice/Provisioning Profiles" || true

      # --- 8) 强制设置 Manual 签名 + 绑定 TEAM/IDENTITY（仅 sdk=iphoneos*）---
      - name: Patch signing in pbxproj (manual + team + identity)
        script: |
          set -euo pipefail
          PBX="ios/Mattermost.xcodeproj/project.pbxproj"
          test -f "$PBX"

          # 统一为手动签名；设置 TEAM；设置发行证书标识（Apple Distribution）
          ruby - <<'RUBY'
          pbx = 'ios/Mattermost.xcodeproj/project.pbxproj'
          s = File.read(pbx)

          # 手动签名
          s.gsub!(/CODE_SIGN_STYLE\s*=\s*Automatic;/, 'CODE_SIGN_STYLE = Manual;')

          # TEAM
          team = ENV['TEAM_ID'] || ''
          raise "TEAM_ID missing" if team.empty?
          s.gsub!(/DEVELOPMENT_TEAM\s*=\s*[A-Z0-9]+;/, "DEVELOPMENT_TEAM = #{team};")

          # 证书标识：仅限制到 iPhoneOS
          s.gsub!(/"CODE_SIGN_IDENTITY\[sdk=iphoneos\*\]"\s*=\s*"[^"]+";/, '"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "Apple Distribution";')
          s.gsub!(/CODE_SIGN_IDENTITY\s*=\s*"[^"]+";/, 'CODE_SIGN_IDENTITY = "Apple Distribution";')

          File.write(pbx, s)
          puts "Patched pbxproj signing (Manual/TEAM/IDENTITY)."
          RUBY

      # --- 9) 为 3 个 target 匹配对应的 Provisioning Profile（Specifier & UUID）---
      - name: Bind provisioning profiles to targets
        script: |
          set -euo pipefail
          PBX="ios/Mattermost.xcodeproj/project.pbxproj"

          # 解析系统中可用的 profiles（简单 grep/awk）
          list_profiles() {
            for p in "$HOME/Library/MobileDevice/Provisioning Profiles/"*.mobileprovision; do
              /usr/bin/security cms -D -i "$p" >/tmp/p.plist
              NAME=$(/usr/libexec/PlistBuddy -c "Print :Name" /tmp/p.plist 2>/dev/null || true)
              UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" /tmp/p.plist 2>/dev/null || true)
              APPID=$(/usr/libexec/PlistBuddy -c "Print :Entitlements:application-identifier" /tmp/p.plist 2>/dev/null || true)
              echo "$NAME|$UUID|$APPID|$p"
            done
          }

          bind_one() {
            local BID="$1"   # bundle id
            local NAME="$2"  # friendly name (for log)
            local LINE
            LINE=$(list_profiles | awk -F'|' -v bid="$TEAM_ID.$BID" '$3==bid {print; exit}')
            if [ -z "$LINE" ]; then
              echo "ERROR: No profile for $BID"; exit 1
            fi
            IFS='|' read PNAME PUUID PAPP PFILE <<<"$LINE"
            echo "Matched $NAME ($BID): $PNAME ($PUUID)"

            # 写入 pbxproj：只改 sdk=iphoneos*
            /usr/bin/perl -0777 -pe "s/\"PROVISIONING_PROFILE_SPECIFIER\\[sdk=iphoneos\\*\\]\" = \".*?\";/\"PROVISIONING_PROFILE_SPECIFIER[sdk=iphoneos*]\" = \"$PNAME\";/g" -i "$PBX"
            /usr/bin/perl -0777 -pe "s/\"PROVISIONING_PROFILE\\[sdk=iphoneos\\*\\]\" = \".*?\";/\"PROVISIONING_PROFILE[sdk=iphoneos*]\" = \"$PUUID\";/g" -i "$PBX"
          }

          bind_one "$APP_BUNDLE_ID"      "Mattermost"
          bind_one "$SHARE_BUNDLE_ID"    "MattermostShare"
          bind_one "$NOTIF_BUNDLE_ID"    "NotificationService"

          echo "Profiles bound in pbxproj."

      # --- 10) 最小 sanity：列出 scheme & 目标 ---
      - name: Sanity check xcodebuild -list
        script: |
          set -euo pipefail
          xcodebuild -project "$PROJECT" -list
          xcodebuild -workspace "$WORKSPACE" -list

      # --- 11) 编译归档 ---
      - name: Build archive
        script: |
          set -euo pipefail
          set -o pipefail
          xcodebuild -workspace "$WORKSPACE" \
            -scheme "$SCHEME" \
            -configuration "$CONFIGURATION" \
            -sdk iphoneos \
            -archivePath ios/build/Mattermost.xcarchive \
            CODE_SIGN_STYLE=Manual \
            COMPILER_INDEX_STORE_ENABLE=NO \
            build archive | xcpretty
          status=${PIPESTATUS[0]}
          exit $status

      # --- 12) 导出 IPA（ad-hoc），显式写入 provisioningProfiles 映射 ---
      - name: Export IPA
        script: |
          set -euo pipefail
          cat > exportOptions.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key>
            <string>${EXPORT_METHOD}</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>${APP_BUNDLE_ID}</key>
              <string>jboth_chat</string>
              <key>${SHARE_BUNDLE_ID}</key>
              <string>jboth_share</string>
              <key>${NOTIF_BUNDLE_ID}</key>
              <string>jboth_notification</string>
            </dict>
            <key>stripSwiftSymbols</key>
            <true/>
            <key>compileBitcode</key>
            <false/>
          </dict>
          </plist>
          EOF

          xcodebuild -exportArchive \
            -archivePath ios/build/Mattermost.xcarchive \
            -exportOptionsPlist exportOptions.plist \
            -exportPath build_output

          ls -lah build_output

    artifacts:
      - build_output/*.ipa
      - ios/build/Mattermost.xcarchive
      - build_output/*.dSYM.zip
      - exportOptions.plist
    publishing:
      email:
        recipients:
          - you@example.com
        notify:
          success: true
          failure: true
